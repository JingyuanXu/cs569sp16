import os
import random
import argparse
import sys
import time
import sut

def print_results():
	if COVERAGE:
		sut.internalReport()
	print "Number of bugs found: " + str(bugs)

parser = argparse.ArgumentParser(description="arguments for mytester.py")

parser.add_argument("time", type=int, help= "time in seconds for testing")
parser.add_argument("seed", type=int, help="seed for Python Random.random object")
parser.add_argument("population", type=int, help="intial population for testing")
parser.add_argument("depth", type=int, help="maximum length of a test generated by your algorithm")
parser.add_argument("fault", type=int, help="If 1, save a test case for each discovered failure")
parser.add_argument("coverage", type=int, help="either 0 or 1 depending on whether a final coverage report should be produced")
parser.add_argument("running", type=int, help=" either 0 or 1 depending on whether running info on branch coverage should be produced")

args = parser.parse_args()

TIMEOUT = args.time
SEED = args.seed
POPULATION = args.population
DEPTH = args.depth
FAULT = args.fault
COVERAGE = args.coverage
RUNNING = args.running
BEST = 10
MODE = "best"

population = []
sut =sut.sut()
actCount = 0
rgen = random.Random()
rgen.seed(SEED)
bugs =0

def double_mutate(test):
	return mutate(mutate(test))

def mutate(test):
	tcopy = list(test)
	i = rgen.randint(0,len(tcopy))
	sut.replay(tcopy[i:]) 
	e = sut.randomEnabled(rgen)
	ok = sut.safely(e)
	
	elapsed = time.time() - start

	if RUNNING:			#should branch coverage be produced 
		if sut.newBranches() != set([]):
	            for b in sut.newBranches():
	                print elapsed,len(sut.allBranches()),"New branch",b


	if not ok: 	#found a bug, report it 
			bugs+=1
			print "Found a FAILURE"
			#sut.prettyPrintTest(sut.test())
			print sut.failure()
			print "REDUCING"
			R = sut.reduce(sut.test(), sut.fails, True, True)
			sut.prettyPrintTest(R)
			print sut.failure()
		
			if FAULT:	#save test to a file if FAULT is enabled
				filename = "failure" + str(bugs) + ".test"
			
				sut.saveTest(R,filename)

	trest = [e]
	for s in tcopy[i+1:]:
		if s[1]():
			trest.append(s)
			ok = sut.safely(s)
			if not ok: 	#found a bug, report it 
				bugs+=1
				print "Found a FAILURE"
				#sut.prettyPrintTest(sut.test())
				print sut.failure()
				print "REDUCING"
				R = sut.reduce(sut.test(), sut.fails, True, True)
				sut.prettyPrintTest(R)
				print sut.failure()
		
				if FAULT:	#save test to a file if FAULT is enabled
					filename = "failure" + str(bugs) + ".test"
			
					sut.saveTest(R,filename)

	tcopy = test[i:] +trest
	return tcopy


start = time.time()

for x in xrange(0,POPULATION):
	sut.restart()
	for s in xrange(0,DEPTH):
		action = sut.randomEnabled(rgen) #get random enabled action
		ok = sut.safely(action) 	#perform action, true if performed without exceptions	
		
		elapsed = time.time() - start
		if RUNNING:			#should branch coverage be produced 
			if sut.newBranches() != set([]):
			    for b in sut.newBranches():
			        print elapsed,len(sut.allBranches()),"New branch",b
		    

		if not ok: 	#found a bug, report it 
			bugs+=1
			print "Found a FAILURE"
			#sut.prettyPrintTest(sut.test())
			print sut.failure()
			print "REDUCING"
			R = sut.reduce(sut.test(), sut.fails, True, True)
			sut.prettyPrintTest(R)
			print sut.failure()
		
			if FAULT:	#save test to a file if FAULT is enabled
				filename = "failure" + str(bugs) + ".test"
			
				sut.saveTest(R,filename)
    	
	population.append((list(sut.test()),set(sut.currBranches())))

while time.time()-start < TIMEOUT:
	sortedPopulation = sorted(population,key = lambda x: len(x[1]),reverse=(MODE=="best"))
	(t,b) = rgen.choice(sortedPopulation[:BEST])
	m = double_mutate(t)
  
	population.append((m,sut.currBranches()))


print_results()	

