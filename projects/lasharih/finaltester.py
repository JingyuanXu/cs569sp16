import os
import random
import argparse
import sys
import time
import sut

def print_results():
	if COVERAGE:
		sut.internalReport()
	print "Number of bugs found: " + str(bugs)

parser = argparse.ArgumentParser(description="arguments for tester1")

parser.add_argument("time", type=int, help= "time in seconds for testing")
parser.add_argument("seed", type=int, help="seed for Python Random.random object")
parser.add_argument("depth", type=int, help="maximum length of a test generated by your algorithm")
parser.add_argument("width", type=int, help="search width")
parser.add_argument("fault", type=int, help="If 1, save a test case for each discovered failure")
parser.add_argument("coverage", type=int, help="either 0 or 1 depending on whether a final coverage report should be produced")
parser.add_argument("running", type=int, help=" either 0 or 1 depending on whether running info on branch coverage should be produced")

args = parser.parse_args()

TIMEOUT = args.time
SEED = args.seed
DEPTH = args.depth
WIDTH = args.width
FAULT = args.fault
COVERAGE = args.coverage
RUNNING = args.running


#print("Argument values:")
#print(TIMEOUT)
#print(SEED)
#print(DEPTH)
#print(WIDTH)
#print(FAULT)
#print(COVERAGE)
#print(RUNNING)


sut =sut.sut()
actCount = 0
rgen = random.Random()
rgen.seed(SEED)
bugs =0

coverCnt = {}
coverLeast = None
perfTest =[]

pCheck = 0.5
goodTest = None

coverCnt = {}
minCoverage = None

start = time.time()

while time.time() - start < TIMEOUT:
	sut.restart() #reset the system state
	if (goodTest != None) and (rgen.random()>pCheck):
        	sut.backtrack(goodTest)
    	boolTest = False    

	for s in xrange(0, DEPTH):
		action = sut.randomEnabled(rgen)#get random enabled action
		ok = sut.safely(action) 	#perform action, true if performed without exceptions
		actCount+=1			#increase action count
		
		if len(sut.newStatements()) > 0:
		    goodTest = sut.state()
		    boolTest = True
		    print "FOUND NEW STATEMENTS",sut.newStatements()
		
		if (not boolTest) and (minCoverage!=None) and (minCoverage in sut.currStatements()):
		    goodTest = sut.state()	 
	            perfTest.append(goodTest) #save test to a set
	
		elapsed = time.time() - start

		if RUNNING:			#should branch coverage be produced 
			if sut.newBranches() != set([]):
		            for b in sut.newBranches():
		                print elapsed,len(sut.allBranches()),"New branch",b
		        
	
		if not ok: 	#found a bug, report it 
			bugs+=1
			print "Found a FAILURE"
			#sut.prettyPrintTest(sut.test())
			print sut.failure()
			print "REDUCING"
			R = sut.reduce(sut.test(), sut.fails, True, True)
			sut.prettyPrintTest(R)
			print sut.failure()
			
			if FAULT:	#save test to a file if FAULT is enabled
				filename = "failure" + str(bugs) + ".test"
				
				sut.saveTest(R,filename)
				

	for s in sut.currStatements():
		if s not in coverCnt:
			coverCnt[s] = 0
			coverCnt[s] += 1    
	    	sortedCov = sorted(coverCnt.keys(), key=lambda x: coverCnt[x])
	    	minCoverage = sortedCov[0]



print_results()	

