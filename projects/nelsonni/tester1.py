#!/usr/bin/python

import sys, sut, random
from optparse import OptionParser

def main(argv):
	parser = OptionParser()
	parser.add_option('-t', '--timeout', action="store", type="int", dest="timeout", default=30, help="time in seconds for testing")
	parser.add_option('-s', '--seed', action="store", type="int", dest="seed", default=10, help="seed for Python random.random object used for random number generation")
	parser.add_option('-d', '--depth', action="store", type="int", dest="depth", default=10, help="maximum length of a test")
	parser.add_option('-w', '--width', action="store", type="int", dest="width", default=10, help="maximum memory/BFS queue/other")
	parser.add_option('-f', '--fault', action="store_true", dest="fault", default=False, help="check for faults in the SUT")
	parser.add_option('-c', '--coverage', action="store_true", dest="coverage", default=False, help="produce a final coverage report")
	parser.add_option('-r', '--running', action="store_true", dest="running", default=False, help="produce running info on branch coverage")

	options, args = parser.parse_args()
	print("timeout:",options.timeout)
	print("seed:\t",options.seed)

	random.seed(options.seed)
	print("random:\t",random.random())

	if(options.fault):
		print("fault:\t enabled")

if __name__ == "__main__":
	main(sys.argv[1:])

"""
<timeout>: time in seconds for testing -- your tester must respect
this, within a small margin of error

<seed>: seed for Python Random.random object used for random number
generation in your code, if it is stochastic

<depth>: maximum length of a test generated by your algorithm

<width>: maximum memory/BFS queue/other parameter that is basically a
search width

<faults>: either 0 or 1 depending on whether your tester should check
for faults in the SUT; if true, you should save a test case for each
discovered failure (terminating the test that generated it), in the
current directory, as failure1.test failure2.test, etc.

<coverage>: either 0 or 1 depending on whether a final coverage report
should be produced, using TSTL's internalReport() function.  Your
tester is allowed to assume that coverage is being collected to guide
tests.  

<running>: either 0 or 1 depending on whether running info on branch
coverage should be produced.
"""